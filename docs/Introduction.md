# Introduction

Messenger is a *message-oriented* (2D) game framework for Elm based on **canvas**. You are only allowed to render objects in that canvas (currently).

Messenger is **not** an elm package, it is a framework so some code will be generated in your project.

## Games that are made with Messenger

I suggest you play the game Reweave. There are many examples explained with that game.

- [Reweave](https://focs.ji.sjtu.edu.cn/silverfocs/demo/2022/p2team01/)
- Waiting for your project!

## Features

- Message oriented programming.
  Safer programming, fewer bugs.
- Auto-adapting.
  Try resizing the web browser or play Reweave on your phone. There are no difference!
- LocalStorage support.
  You can easily manage the game data.
- Audio Manager.
  It's extremely easy to play audios in Messenger. You can choose to play one audio in loop mode or once mode.
- Easy textures and sprites.
  It's easy to import textures to your game. The game will not start until all textures are loaded, so the user won't have problems with failing assets or slow loading speed.
- Canvas rendering.
  You can use huge amounts of filters in canvas to render the game. It has better performance than the DOM rendering.
- Modular development.
  Every component, layer, scene is a module, no worry for the code management.

## Possible drawbacks

There are some bugs and drawbacks of Messenger:

- Canvas based.
  You cannot use HTML tags like `video`, `a`, `b`, etc. and any css are not available in canvas. Videos are not currently possible due to elm-canvas package limitations, but it can be achieved in other ways.
- Mouse click can arise multiple layers.
  Normally when you click some object in the web page, only the top object will response. Currently Messenger doesn't implement the `Stopper` function in the `layerHandler` module so all the layers will handle that click event.

## FAQ

- Q: What kind of games can I use Messenger to make?
- A: Any video games that have the concept of scenes and layers.
- Q: Is it suitable for a mouse-interactive game?
- A: Currently the mouse event doesn't support shadowing by default. However it is possible to implement it by changing the layer handler module.

## Conceptual Picture

![](imgs/concept.png)

- Red arrow: messages that are sent positively
- Orange arrow: messages that are triggered passively

A **Scene** is a literally a *scene*. A game may have many different scenes. In Reweave, there are about 10 scenes:

- Home
- Level0 to Level5
- Level4boss and Level5boss
- Path
- End

You can use the console (component) in the game (press \` in the main game) to load different scenes by entering some command like `load Level2 `. However, writing a new scene is a heavy work, when some scenes are very similar, we can write a *SceneProto* that can generate scenes given some arguments. In fact, only `Home` scene in Reweave are written from scratch, and all the other level scenes are generated by the `CoreEngine` SceneProto. You probably need to write your own SceneProto when making a game.

When we are talking about "communicate", it is the behavior that one object sends some message to the other object.

A Scene will contain several **Layers**. Different layers have different orders when rendering, so you can separate one scene to background layer and frontground layer for rendering different objects. Layers can communicate with each other, and can also communicate with the parent scene. This pattern is the core mechanism in Messenger. We will see this again later. In short, layers are used to separate objects that are rendered with different orders.

A Layer (may) contain several **Components**. You can have no component and only use the layer as a background image layer. Components are also able to communicate with each other and communicate with the parent layer.

In the next chapter, we will see how to create a new Messenger project.

## Why not a package?

Some people may ask why you don't build all those things into an elm package and there are several reasons.

Elm is a very elementary expression language. It mimics the Haskell, but only contains a subset of it and change some syntax to make it easier to use. A key difference between Elm and Haskell (or PureScript) is that Elm **doesn't work on polymorphisms**. On one hand, polymorphisms in functional programming languages are tricky and diverse, on the other hand, a language with no polymorphisms or other similar functions are too weak for writing a project. There are some cases that you have to write duplicate codes.

Elm packages are independent of the game source code. However, there are some types that need to be defined in the game rather than in the package. So if the package want to use that type, it must stay with the game code.
